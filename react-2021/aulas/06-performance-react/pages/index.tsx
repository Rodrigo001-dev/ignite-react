import Head from 'next/head';
import { Inter } from '@next/font/google';
import { FormEvent, useCallback, useState } from 'react';

import { SearchResults } from '../components/SearchResults';

const inter = Inter({ subsets: ['latin'] })

type Results = {
  totalPrice: number;
  data: any[];
}

export default function Home() {
  const [search, setSearch] = useState('');
  const [results, setResults] = useState<Results>({
    totalPrice: 0,
    data: []
  });

  async function handleSearch(event: FormEvent) {
    event.preventDefault();

    // se ele estiver vazio ele para aqui
    if (!search.trim()) {
      return;
    }

    // o q vem de query
    const response = await fetch(`http://localhost:3333/products?q=${search}`);
    const data = await response.json();

    const formatter = new Intl.NumberFormat('pt-BR', {
      style: 'currency',
      currency: 'BRL'
    });

    // aqui eu estou fazendo a formatação dos dados quando eu estou buscando 
    // as informações e não fazer no momento que eu vou exibir as informações
    // isso vai evitar que eu fique criando um monte de useMemo e vai permitir que
    // eu tenha o menor custo de processamento
    const products = data.map((product: any) => {
      return {
        id: product.id,
        title: product.title,
        price: product.price,
        priceFormatted: formatter.format(product.price),
      }
    });

    const totalPrice = data.reduce((total: number, product: any) => {
      return total + product.price;
    }, 0)

    setResults({ totalPrice, data: products });
  }

  // o useCallback tem quase o mesmo funcionamento do useMemo, só que ao invés
  // de ser um valor(variável), vai ser uma função, ou seja, quando criamos uma
  // função e essa função vai ser repassada para os componentes filhos da
  // aplicação é importante que essa função utilize o useCallback, isso vale
  // também quando estamos criando Contextos
  // o useCallback é utilizado apenas por uma questão de igualdade referencial,
  // porque toda vez que o componente Home atualiza, a função addToWishlist é
  // criada do zero, ou seja, ela ocupa um novo espaço na memória, como essa
  // fução está sendo passada para o SearchResults, toda vez que eu tiver essa
  // função recriada na memória(toda vez que o componente renderizar) o 
  // SearchResults vai perceber que a função(addToWishlist) é diferente porque
  // ele faz uma verificação de igualdade referencial e com isso vai recriar
  // o SearchResults do zero
  const addToWishlist = useCallback(async (id: number) => {
    console.log(id);
  }, []);

  return (
    <>
      <Head>
        <title>Performance React</title>
        <meta name="description" content="Generated by create next app" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <main>
        <div>
          <h1 className={inter.className}>Search</h1>

          <form onSubmit={handleSearch}>
            <input 
              type="text" 
              value={search} 
              onChange={e => setSearch(e.target.value)}
            />

            <button type="submit">Buscar</button>
          </form>

          <SearchResults
            results={results.data}
            totalPrice={results.totalPrice}
            onAddToWishlist={addToWishlist}
          />
        </div>
      </main>
    </>
  )
}
